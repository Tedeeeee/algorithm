# 🔍 DFS (Depth-First Search)

DFS는 **한 방향으로 갈 수 있을 때까지 끝까지 내려간 뒤**,  
더 이상 갈 수 없으면 **이전 지점으로 되돌아오는 탐색 방식**이다.

코딩테스트에서 DFS는 단순 탐색이 아니라  
👉 **구조를 파악하고, 영역을 나누고, 경우의 수를 설계하는 도구**다.

---

## 언제 DFS를 떠올려야 하나?
아래 문장이나 상황이 보이면 DFS를 1순위로 의심한다.

- 연결된 영역의 개수를 구하라
- 한 덩어리인지 판단하라
- 모두 연결되어 있는가?
- 갈 수 있는 모든 경우를 시도하라
- 특정 조건을 만족하는 경로가 존재하는가?
- 트리 / 그래프 / 격자(2D, 3D)

📌 핵심 신호
> **“한 번 들어가면 끝까지 가봐야 한다”**

---

## DFS의 핵심 사고 (이게 제일 중요)
DFS는 단순히 “깊게 간다”가 아니다.  
**현재 상태를 기준으로 다음 상태로 전이하는 사고**다.

즉, DFS 문제는 항상 이 질문으로 시작한다.

> “지금 이 상태에서,  
> 내가 할 수 있는 다음 선택은 뭐지?”

---

### DFS 사고 흐름 (공식처럼 외우기)
1. **현재 위치에서 해야 할 일 정의**
    - 카운트 증가
    - 값 누적
    - 조건 체크
2. **방문 처리**
    - 다시 돌아오지 않기 위해
3. **갈 수 있는 모든 다음 위치로 이동**
4. **더 이상 못 가면 되돌아오기**

📌 DFS = **상태 전이 + 되돌아오기**

---

## DFS 구현 방식

### 1️⃣ 재귀 DFS (가장 많이 사용)
- 코드가 가장 직관적
- 트리, 그래프, 격자 문제에 최적
- 깊이가 깊으면 스택 오버플로우 위험

📌 이런 문제에서 주력
- 단지 번호
- 섬 개수
- 트리 순회

---

### 2️⃣ 스택 DFS
- 재귀 대신 명시적 스택 사용
- 깊이 제한이 걱정될 때
- 재귀가 금지된 환경

📌 거의 안 쓰지만  
“재귀 DFS = 스택 DFS”라는 개념 이해용으로 중요

---

## DFS가 자주 쓰이는 문제 유형

- 연결 요소 개수 세기
- 섬 / 단지 / 구역 문제
- 트리 순회
- 경로 존재 여부 판단
- 백트래킹의 기반 (순열, 조합, 부분집합)

📌 DFS는 **탐색 알고리즘이자 설계 도구**다.

---

## DFS에서 반드시 체크해야 할 것들
문제 풀기 전에 이 질문을 던져라.

- 방문 배열이 필요한가?
- 방문 처리는 언제 해야 하는가?
- 부모로 되돌아가는 걸 어떻게 막을 것인가?
- 종료 조건은 명확한가?
- 상태를 되돌려야 하는가? (백트래킹)

---

## 자주 하는 실수 (진짜 많이 나오는 것들)
- 방문 처리를 늦게 해서 무한 재귀 발생
- 부모 노드를 다시 방문함
- 종료 조건 없이 DFS 호출
- 재귀 깊이 제한 고려 안 함
- 백트래킹 문제에서 상태 복원 누락

📌 DFS 문제의 70%는  
👉 **로직이 아니라 방문 처리 실수**다.

---

## DFS vs BFS (감각적으로 구분)

| 구분 | DFS | BFS |
|----|----|----|
| 탐색 기준 | 한 갈래 끝까지 | 가까운 곳부터 |
| 주 용도 | 구조 / 경우의 수 | 최단 거리 |
| 자료구조 | 재귀 / 스택 | 큐 |
| 사고 방식 | 설계 중심 | 거리 중심 |

📌 헷갈릴 때 기준
> “거리 / 최소 횟수” → BFS  
> “구조 / 덩어리 / 경우” → DFS

---

## 문제 기록

### <img src="https://static.solved.ac/tier_small/9.svg" width="13px" />&nbsp;[BOJ 1260 - DFS 와 BFS](https://www.acmicpc.net/problem/1260) (BFS문제랑 같이 있음)
- 왜 이 알고리즘을 썼는지
- 시간복잡도
- 실수 포인트 1개

---

## 한 줄 요약
> **“DFS는 한 갈래를 끝까지 파고들어  
> 구조와 경우의 수를 파악하는 도구다.”**
