# 🧠 DP (Dynamic Programming)

DP(Dynamic Programming)는  
**이미 계산한 결과를 다시 계산하지 않도록 저장해서 문제를 푸는 방식**이다.

코딩테스트에서 DP는  
👉 “어려운 알고리즘”이 아니라  
👉 **문제를 ‘중복되는 구조’로 바라보는 사고 방식**이다.

---

## 언제 DP를 떠올려야 하나?
문제에서 아래 신호가 보이면 DP를 의심한다.

- 같은 계산을 반복한다
- 이전 결과가 다음 결과에 영향을 준다
- 최댓값 / 최솟값을 구한다
- 경우의 수를 센다
- 선택을 되돌릴 수 있다
- 그리디로 풀면 반례가 나온다

📌 핵심 신호
> **“이거… 앞에서 계산한 걸 또 쓰는 것 같은데?”**

---

## DP의 핵심 사고
DP의 본질은  
**“큰 문제를 작은 문제로 쪼갤 수 있는가?”**다.

그리고 그 작은 문제들이  
👉 **서로 겹치는지(중복)** 가 핵심이다.

그래서 항상 이 질문을 던져야 한다.

> “이 문제를  
> 하나 작은 문제로 정의할 수 있는가?”

YES → DP 가능  
NO → DP ❌

---

## DP 사고 흐름 (공식처럼)

1. **상태 정의 (DP 배열 의미 정하기)**
    - dp[i]가 무엇을 의미하는가?
2. **점화식 도출**
    - dp[i]는 어떤 dp[j]로부터 오는가?
3. **초기값 설정**
4. **계산 순서 결정**
    - 작은 것 → 큰 것
5. **정답 위치 확인**

📌 DP는  
👉 “dp 배열 정의가 80%”다.

---

## DP의 대표 유형

### 1️⃣ 1차원 DP
- 이전 값 하나 또는 몇 개만 참조

📌 예시 사고
- dp[i] = i번째까지의 최적값

---

### 2️⃣ 2차원 DP
- 두 가지 기준이 필요할 때

📌 예시 사고
- dp[i][j] = i까지 고려했을 때 j상태의 결과

---

### 3️⃣ 선택형 DP
- 선택 / 비선택
- 포함 / 미포함

📌 배낭 문제 계열

---

## DP 문제에서 반드시 점검할 것들
문제 풀기 전에 이걸 체크해라.

- dp 배열의 의미가 명확한가?
- 점화식이 말로 설명되는가?
- 초기값이 빠지지 않았는가?
- 계산 순서가 올바른가?
- 그리디로는 안 되는 이유가 있는가?

---

## DP에서 자주 하는 실수
(진짜 많이 틀린다)

- dp 의미가 모호함
- 점화식 잘못 세움
- 초기값 누락
- 범위 초과
- 메모리 / 시간 초과

📌 DP는  
👉 **코드보다 설계가 중요**하다.

---

## DP vs 다른 알고리즘
이 구분이 되면 헷갈리지 않는다.

- 되돌릴 수 없는 선택 → 그리디
- 모든 경우 → 브루트포스
- 최단 거리 → BFS
- 중복 계산 제거 → DP

---

## DP 문제 접근 요령 (실전 팁)
문제 읽고 바로 DP로 가지 마라.

1️⃣ 브루트포스로 풀어본다  
2️⃣ 중복되는 계산을 찾는다  
3️⃣ 그걸 dp 배열로 옮긴다

📌 **브루트포스 → DP**  
이 흐름이 가장 안전하다.

---

## 문제 기록
(※ **직접 푼 문제만 작성**)

### <img src="https://static.solved.ac/tier_small/4.svg" width="13px" />&nbsp;[BOJ 2747 - 피보나치 수](https://www.acmicpc.net/problem/2747)

- dp 상태 정의
- 점화식
- 시간복잡도
- 실수 포인트 1개

---

## 한 줄 요약
> **“DP는  
> 문제를 기억하게 만드는 기술이다.”**
