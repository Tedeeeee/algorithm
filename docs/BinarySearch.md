# 🔍 Binary Search (이진 탐색)

이진 탐색(Binary Search)은  
**정렬된 데이터에서 탐색 범위를 절반씩 줄여가며 값을 찾는 알고리즘**이다.

코딩테스트에서 이진 탐색은  
👉 “빠르게 찾는 기술”이 아니라  
👉 **문제를 로그 단위로 줄이는 사고 방식**이다.

---

## 언제 이진 탐색을 떠올려야 하나?
문제에서 아래 신호가 보이면 이진 탐색을 의심한다.

- 정렬된 데이터
- 값의 존재 여부
- 조건을 만족하는 최소 / 최대
- 답이 범위 안에 있다
- N이 크다 (10⁵ 이상)

📌 핵심 신호
> **“선형 탐색하면 터질 것 같다”**

---

## 이진 탐색의 핵심 사고
이진 탐색의 본질은  
**“정답이 이쪽에 있는지, 저쪽에 있는지 판별한다”**는 것이다.

그래서 항상 이 질문을 던져야 한다.

> “중간값을 기준으로  
> 답이 왼쪽에 있는가, 오른쪽에 있는가?”

YES / NO가 명확해야  
👉 이진 탐색이 가능하다.

---

## 이진 탐색 사고 흐름 (공식처럼)

1. **정렬되어 있는가?**
2. **left / right 범위 설정**
3. **mid 기준 판단 조건 정의**
4. **범위 절반 제거**
5. **종료 조건 명확화**

📌 이 순서를 벗어나면  
👉 무한 루프가 난다.

---

## 이진 탐색의 대표 유형

### 1️⃣ 값 존재 여부 탐색
- 특정 값이 있는지?
- 몇 개 있는지?

📌 기본 형태

---

### 2️⃣ Lower Bound / Upper Bound
- 처음 등장 위치
- 조건을 만족하는 최소값

📌 “같으면 멈춘다” ❌  
📌 “조건을 만족하는 첫 지점” ⭕

---

### 3️⃣ 파라메트릭 서치
- 정답을 직접 찾지 않고
- 가능한지 여부만 판별

📌 “될까? 안 될까?” 로 접근

---

## 이진 탐색 문제에서 반드시 점검할 것들
문제 풀기 전에 이걸 체크해라.

- 정렬이 선행됐는가?
- mid 계산이 안전한가?
- left / right 갱신이 올바른가?
- 종료 조건이 명확한가?
- 같은 값 처리 규칙이 있는가?

---

## 이진 탐색에서 자주 하는 실수
(진짜 많이 나온다)

- 정렬 안 하고 시작
- mid 계산 실수
- left < right / <= 혼동
- 조건 분기 반대로 작성
- 무한 루프

📌 이진 탐색은  
👉 **사고가 흐트러지면 바로 틀린다.**

---

## 이진 탐색 vs 다른 알고리즘
이 구분이 되면 선택이 빨라진다.

- 범위 줄이기 → 이진 탐색
- 정렬 + 두 값 → 투 포인터
- 모든 경우 → 브루트포스
- 최단 거리 → BFS

---

## 문제 기록
(※ **직접 푼 문제만 작성**)

### <img src="https://static.solved.ac/tier_small/10.svg" width="13px" />&nbsp;[BOJ 1920 - 수 찾기](https://www.acmicpc.net/problem/1920)
### <img src="https://static.solved.ac/tier_small/9.svg" width="13px" />&nbsp;[BOJ 1654 - 랜선자르기](https://www.acmicpc.net/problem/1654)
- 왜 이진 탐색을 썼는지 : 자를 수 있는 길이를 하나씩 확인하면 비효율적이라, 조건이 단조적으로 변하는 길이를 기준으로 이진 탐색을 사용한다
- 시간복잡도 : O(n log maxLen)
- 실수 포인트 1개 : 랜선 갯수의 합이 int 범위를 초과할 수 있어 long 을 사용해야 한다

### <img src="https://static.solved.ac/tier_small/6.svg" width="13px" />&nbsp;[BOJ 10815 - 숫자 카드](https://www.acmicpc.net/problem/10815)
- 왜 이진 탐색을 썼는지 : 카드의 갯수가 O(n2)으로 해결할 수 없기에 이분탐색을 사용
- 시간복잡도 : O(n log n)
- 실수 포인트 1개 : X

### <img src="https://static.solved.ac/tier_small/9.svg" width="13px" />&nbsp;[BOJ 2805 - 나무 자르기](https://www.acmicpc.net/problem/2805)
- 왜 이분 탐색을 썼는지 : 목표하는 최대 나무 길이는 20억이 넘고 나무 갯수는 100만개가 넘기에 2중for문은 문제가 될 수 있음 
- 시간복잡도 : O(n log n)
- 실수 포인트 1개 : 구하고자 하는 나무의 총 길이가 20억이 넘기에 더하는 과정에 int 범위를 넘어설수 있음 그래서 long 을 answer값으로 사용해야 하는데 그렇게 못함

### <img src="https://static.solved.ac/tier_small/12.svg" width="13px" />&nbsp;[BOJ 2295 - 세 수의 합](https://www.acmicpc.net/problem/2295)
- 왜 이분 탐색을 썼는지 : <br/>
  네 수의 조합을 그대로 탐색하면 O(n³) 이상이 되므로, 식을 `x + y = k - z` 형태로 변형하여 두 수의 합을 미리 계산했다. <br/>
  이후 `k - z` 값이 두 수의 합 배열에 존재하는지 빠르게 확인하기 위해 **정렬 + 이분 탐색**을 사용했다.<br/>
  이분 탐색은 문제의 핵심이 아니라 **탐색 비용을 줄이기 위한 도구**였다.

- 시간복잡도 : <br/>
    - 두 수의 합 생성: O(n²)
    - 정렬: O(n² log n)
    - k, z 탐색 + 이분 탐색: O(n² log n)
      → 전체 시간복잡도는 **O(n² log n)**

- 실수 포인트 : <br/>
  단순한 구현 문제가 아니라, `x + y + z = k`를 `x + y = k - z`로 변형하는 **수학적 사고(조합 분해)** 가 핵심이다. <br/>
  또한 값의 범위가 커서 **int 오버플로우**가 발생할 수 있으므로 두 수의 합은 `long`으로 관리해야 한다.

### <img src="https://static.solved.ac/tier_small/11.svg" width="13px" />&nbsp;[BOJ 18869 - 멀티버스 2](https://www.acmicpc.net/problem/18869)
- 왜 이분 탐색을 썼는지 : <br/> 각 우주의 행성 배열을 좌표 압축(rank 배열) 으로 바꿀 때, 정렬된 유니크 배열에서 각 값의 순위(= lower_bound 위치) 를 찾아야 한다. 이 순위는 “나보다 작은 값의 개수”라서 상대적 대소관계를 그대로 보존하고, 이 위치를 빠르게 찾기 위해 이분 탐색을 사용할 수 있다. (Java Arrays.binarySearch 또는 직접 lower_bound 구현)

- 시간복잡도 : <br/>
  - 우주 1개 처리: 정렬 O(N log N) + 각 원소 rank 찾기 O(N log N)
  - 전체: O(M * N log N) (M=우주 수, N=행성 수)
  - 추가로 패턴 묶기(Map)는 O(M * N) 수준이라 정렬 비용이 지배적

- 실수 포인트 :
  - 중복 처리: 같은 값은 같은 rank여야 함(유니크 배열/첫 위치 사용).
  - 입력 변수 의미(M, N) 혼동: 우주 수/행성 수를 바꿔 읽으면 배열 크기부터 꼬임.
  - 전수 비교로만 세기: 제한에서는 통과 가능해도 O(M^2 * N)이라 최악이 커질 수 있음 → 패턴을 문자열 키로 묶고 c*(c-1)/2로 계산하면 안정적.
  - 조합 계산 자료형: 쌍 계산은 습관적으로 long으로 처리(오버플로 예방).

---

## 한 줄 요약
> **“이진 탐색은  
> 정답이 있는 쪽만 남기는 사고다.”**
